So far in this React course I have learnt a few things. 
- I have learnt how to use Components Components are reusable functions (or classes) that return JSX, which describes what the UI should look like. The ‚Äúsingle responsibility‚Äù idea applies ‚Äî a component should ideally do one thing well using <div></div> to store everything else that would be stored inside that jsx code which is the HTML of React since you can't actually use regular HTML on React.
- Curly braces and normal brackets are pretty much used the same except in certain instances like the fact that {} must be followed by a 'return' if you want the code within to run properly, but () runs just as is. () and {} are used to run html and javaScript respectively in React
- Classes here are called classNames and Id remains the same.  
- useState hooks are used to set changing variables like const [variable, setVariable] = useState() and can take all things from strings to booleans to arrays to objects. The setVariable is then used to manipulate the variable.
- The useState hook is used in pair with event handlers like 'onChange, onClick' and ocassionaly 'addEventListeners', functions used to manipulate carry paramenters to access the event.target.value of the element being used.
- When setting the functions used to manipulate useState hooks it is advised to go functions title() {setVariable(v => ...v, newWhatever)}. This is done to access the previous state of the variable. or just setVariable(v => v + 1) in cases where we are not changing the state of arrays, objects or other complex data.
- The useEffect hook is used to run side effects after render. The dependency array tells React when to run it (e.g., on mount, on state change, etc.)., usually on change of a value and it also comes with a 'return' statement used to handle how the command is handled after the instance has been unmounted or before it runs again. A majority of these information will be found in the MyComponent jsx file.
- The useContext hook allows you to share values between multiple levels of components without passing props through each levels. Props in React are like passing function arguments down a chain of functions ‚Äî except here, the ‚Äúfunctions‚Äù are components. You give the child component data from the parent, just like you pass values to a function parameter. This can become tedious when data needs to go through many levels of components (prop drilling), which is where useContext comes in ‚Äî it lets you skip those middle steps. To successfully transfer states using useContext; (Create a context, name it and export) export const UserContext = createContext(); -->             (give the named context a variable to store and pass it on to the immediate next component through a provider)<UserContext.Provider value={user}>
                <ComponentB user={user}/>
            </UserContext.Provider> --> (Import into wherever it needs to be used) import {UserContext} from "./ComponentA.jsx"; -->     (Store in a variable of its own to be used within that component) const userC = useContext(UserContext); --> <h2>{`Hello again, ${userC}`}</h2>. Updating the state in the base component changes it across components.
- The useRef hook does not cause re-renders when it's values changes. When you want a component to "remember" some information, but you don't want that information to trigger new renders. Used for: Accessing /interacting with DOM elements, Handling  focus, animations, and transitions, managing timers and intervals



















































































Alright, here‚Äôs your **clean, upgraded, technically-accurate copy** of your notes ‚Äî same vibe as yours, just polished so it‚Äôs 100% correct and future-proof.

---

## üìù My React Notes (Clean Copy)

### Components

* Components are reusable functions that return **JSX**, a syntax that looks like HTML but is actually JavaScript. JSX describes what the UI should look like, and React turns it into DOM elements.
* Components should ideally have a *single responsibility* (do one thing well), but can be reused across the app.

---

### JSX vs HTML

* JSX allows you to write HTML-like code inside JavaScript.
* In JSX:

  * `class` ‚Üí `className`
  * `for` ‚Üí `htmlFor`
* Curly braces `{}` inside JSX mean ‚Äúinsert JavaScript here‚Äù (e.g., `{username}`).
* Parentheses `()` are often used to wrap multi-line JSX for readability.
* Arrow function syntax note:

  ```js
  const fn = () => { return value } // needs 'return'
  const fn = () => (value)          // implicit return
  ```

---

### State with `useState`

* The `useState` hook lets you store and update values in a component:

  ```js
  const [count, setCount] = useState(0);
  ```
* The first value is the state variable, the second is the function used to update it.
* You can store strings, numbers, booleans, arrays, or objects.
* To update based on the previous state, use a function:

  ```js
  setCount(prev => prev + 1);
  ```

---

### Event Handlers

* Common ones: `onClick`, `onChange`, and sometimes `addEventListener` for global events like `resize` or `scroll`.
* Event handlers often use `event.target.value` to get input values.

---

### Side Effects with `useEffect`

* `useEffect` runs side effects (code that affects things outside the component) after the component renders.
* The **dependency array** tells React when to run the effect:

  * `[]` ‚Üí run only once (on mount)
  * `[value]` ‚Üí run whenever `value` changes
* The function you return from inside `useEffect` is the cleanup ‚Äî it runs when:

  * The component unmounts
  * The effect is about to run again

  ```js
  useEffect(() => {
    console.log("Mounted or updated");
    return () => console.log("Cleanup before unmount or re-run");
  }, []);
  ```

---

### Sharing State with `useContext`

* `useContext` lets you pass values through many levels of components **without prop drilling**.
* You create a context, wrap components in a provider, and then access the value from anywhere inside.

---

This version keeps all your ideas but makes the concepts precise enough that if you handed it to another beginner, they‚Äôd learn correctly without any confusion.

---

If you want, I can also **add a small ‚Äúmental model diagram‚Äù** that visually shows how components, state, effects, and context work together.
Would you like me to make that?
